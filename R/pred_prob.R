#' Compute predicted transition/emission probabilities given certain values of covariates
#'
#'
#' @param object Object of class \code{mHMM}, generated by the function
#'   \code{\link{mHMM}}.
#' @param covariate Either a numeric vector specifying the values of covariates.
#' @param component String specifying if the prediction should be made
#' for the transition probability matrix gamma (\code{component = "gamma"}),
#' or for the emission distribution probabilities (\code{component = "emiss"}).
#' In case of the latter and the model is based on multiple dependent variables,
#' the user has to indicate a specific dependent variable, see \code{dep}.
#' @param dep Integer specifying for which dependent variable the predicted e
#' mission probabilities are computed.
#' @export

pred_probs <- function(object, covariate, component = "gamma", dep = 1, cat_lab, dep_lab,...){
  if (!is.mHMM(object)){
    stop("The input object should be from the class mHMM, obtained with the function mHMM.")
  }
  if (component != "gamma" & component != "emiss"){
    stop("The input specified under component should be a string, restrectid to state either gamma or emiss.")
  }
  input   <- object$input
  dep_labels <- input$dep_labels
  burn_in <- input$burn_in
  J       <- input$J
  m       <- input$m
  q_emiss <- input$q_emiss
  n_dep   <- input$n_dep

  # if predict gamma
  if(component == "gamma"){
    int <- object$gamma_int_bar
    cov <- object$gamma_cov_bar
    regr_cov <- matrix(NA, nrow = 2, ncol = m-1)
    res <- list()
      for(i in 1:m){
        regr_cov[1,] <-  apply(matrix(int[(burn_in + 1):J,(((i-1) * (m-1)) + 1) : (((i-1) * (m-1)) + m-1) ], ncol = m-1), 2, mean)
        regr_cov[2,] <-  apply(matrix(cov[(burn_in + 1):J,(((i-1) * (m-1)) + 1) : (((i-1) * (m-1)) + m-1) ], ncol = m-1), 2, mean)
        pred_tr2 <- list()
        for(c in 1:length(covariate)){
        regr_cov[2,] <- regr_cov[2,]*covariate[c]
        regr_matrix <- cbind(rep(0,2), regr_cov)
        exp_regr <- exp(apply(regr_matrix,2,sum)) # int_to_prob doesn't have this summing step...
        pred_tr <- as.data.frame(t(exp_regr / as.vector(exp_regr %*% c(rep(1, (length(exp_regr)))))))
        pred_tr2[[c]] <- pred_tr %>%
          dplyr::rename_with(~paste0("To_state_", 1:m)) %>%
          dplyr::mutate(From_state = paste("State", i),
                        covariate = covariate[c]) %>%
          dplyr::relocate(From_state, covariate, .before = To_state_1)
        }
        pred_tr2 <- purrr::list_rbind(pred_tr2)
        res[[i]] <- pred_tr2
      }
    res <- purrr::list_rbind(res)
    # if predict emiss
  } else if (component == "emiss"){
    if (missing(cat_lab)){
      cat_lab <- paste("Category", 1:q_emiss[dep])
    }
    if (missing(dep_lab)){
      dep_lab <- input$dep_labels[dep]
    }
    int <- object$emiss_int_bar[[dep]]
    cov <- object$emiss_cov_bar[[dep]]
    res <- list()
    for(c in 1:length(covariate)){
      int_mat <- cbind(rep(0, m), matrix(apply(int[((burn_in + 1): J),], 2, mean), byrow = TRUE, ncol = q_emiss[dep]-1, nrow = m))
      cov_mat <- cbind(rep(0, m), matrix(apply(cov[((burn_in + 1): J),], 2, mean), byrow = TRUE, ncol = q_emiss[dep]-1, nrow = m) * covariate[c])

      reg_mat <- exp(int_mat + cov_mat)
      res[[c]] <- as.data.frame(t(apply(reg_mat, 1, function(x) x / as.vector(x%*% c(rep(1, length(x))))))) %>%
        dplyr::rename_with(~paste0("Category", 1:q_emiss[dep])) %>%
        dplyr::mutate(
          State = paste0("State", 1:m),
          covariate = covariate[c]
        ) %>%
        dplyr::relocate(State, covariate, .before = Category1)
    }
    res <- purrr::list_rbind(res)
    #cat("Dependent variable:", dep_lab, "\n")
  }
  return(res)
}

utils::globalVariables(c("From_state", "To_state_1", "Category1"))


# try out

# pred_probs(object, h)
#
# pred_probs(object, 0.4)
#
# pred_probs(object, covariate= h, component = "emiss", dep = 1)
#
# pred_probs(object, covariate= 0.3)


# map_dfr(h, ~pred_prob(object, x = .x, component = "emiss"))
#
# h <- seq(-3,3,.5)
#
# map_dfr(h, ~pred_prob(object, x = .x))
# pred_prob(object, x = h)


