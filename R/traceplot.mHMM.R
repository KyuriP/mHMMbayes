#' Plotting the traceplots of chains
#'
#'
#' @param L a list of objects of class \code{mHMM} generated by the \code{\link{mHMM}} function.
#' @param component String specifying if the displayed posterior densities
#'   should be for the transition probability matrix gamma (\code{component =
#'   "gamma"}), or for the emission distribution probabilities (\code{component
#'   = "emiss"}). In case of the latter and the model is based on multiple
#'   dependent variables, the user has to indicate for which dependent variable
#'   the posterior densities have to be plotted, see \code{dep}.
#' @param dep Integer specifying for which dependent variable the posterior
#'   densities should be plotted. Only required if one wishes to plot the
#'   emission distribution probabilities and the model is based on multiple
#'   dependent variables.
#' @param col Vector of colors for the posterior density lines. If one is
#'   plotting the posterior densities for gamma, the vector has length \code{m}
#'   (i.e., number of hidden states). If one is plotting the posterior densities
#'   for the emission probabilities, the vector has length \code{q_emiss[k]}
#'   (i.e., the number of outcome categories for the dependent variable
#'   \code{k}).
#' @param cat_lab Optional vector of strings when plotting the posterior
#'   densities of the emission probabilities, denoting the labels of the
#'   categorical outcome values. Automatically generated when not provided.
#' @param dep_lab Optional string when plotting the posterior
#'   densities of the emission probabilities with length 1, denoting the label
#'   for the dependent variable plotted. Automatically obtained from the input
#'   object \code{x} when not specified.
#' @param burn_in An integer which specifies the number of iterations to discard
#'   when obtaining the model parameter summary statistics. When left
#'   unspecified, the burn in period specified at creating the \code{mHMM}
#'   object with the function \code{\link{mHMM}} will be used.
#'
#' @import magrittr
#' @export

utils::globalVariables(c("chain", "iteration", "value", "%>%"))

traceplot.mHMM <- function(L, component = "gamma", dep = 1, col, cat_lab,
                           dep_lab, burn_in, ...){
  if(!any(sapply(L, is.mHMM))){
    stop("Every input object of list L should be from the class mHMM, obtained with the function mHMM.")
  }
  if (component != "gamma" & component != "emiss"){
    stop("The input specified under component should be a string, restrectid to state either gamma or emiss.")
  }
  if (missing(burn_in)){
    burn_in <- L[[1]]$input$burn_in
  }
  J       <- L[[1]]$input$J
  if (burn_in >= (J-1)){
    stop(paste("The specified burn in period should be at least 2 points smaller
               compared to the number of iterations J, J =", J))
  }

  old_par <- graphics::par(no.readonly =TRUE)
  on.exit(graphics::par(old_par))
  m       <- L[[1]]$input$m
  q_emiss <- L[[1]]$input$q_emiss
  n_dep   <- L[[1]]$input$n_dep
  nchain <- length(L)

  # if plotting gamma
  if(component == "gamma"){
    # when ggplot2 & dplyr are available
    if(nzchar(system.file(package = "ggplot2")) && nzchar(system.file(package = "dplyr"))){

      # extract gamma matrices
      object <- purrr::map_dfr(1:length(L), ~ {
        L[[.x]]["gamma_prob_bar"]%>% as.data.frame() %>% dplyr::rename_with(~sub(".*bar.", "", .x)) %>%
          dplyr::mutate(iteration = dplyr::row_number()) %>% dplyr::slice(burn_in:J)
      } ,
      .id="chain") %>% tidyr::pivot_longer(!c(chain, iteration), names_to = "states", values_to = "value")

      # create traceplots
      if (nchain <= 1) {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value))
      } else {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value, colour = as.factor(chain)))
      }
      f <- f + ggplot2::geom_line(alpha=0.7) +
        ggplot2::scale_colour_discrete(name="Chain") +
        ggplot2::facet_wrap(~ states, ncol=1, scales="free")+
        ggplot2::labs(title = "transition probabilities", y = "")

      # when ggplot2 is not available, use baseR
    } else {

      if (missing(col)){
        state_col <- grDevices::rainbow(m)
      } else {
        state_col <- col
      }
      # specify layout
      graphics::par(mfrow = c(m * m, 1))
      # graphics::par(mfrow = c(2, ceiling(m/2)), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))

      f <- for(i in 1:m){
        # find min and max y
        maxy <- miny <- 0
        for(j in 1:m){
          newmax <- max(sapply(L, function(x) max(x$gamma_prob_bar[burn_in:J, m * (i-1) + j])))
          newmin <- min(sapply(L, function(x) min(x$gamma_prob_bar[burn_in:J, m * (i-1) + j])))
          if(newmax > maxy) maxy <- newmax
          if(newmin < miny) miny <- newmin
        }
        for(j in 1:m){
          graphics::plot.default(x = 1, xlim = c(burn_in, J), ylim = c(miny, maxy), type = "n", cex = .8,
                                 ylab = "transition probability", xlab = "iteration")
          for(k in 1:nchain){
            graphics::lines(x = burn_in:J, y = L[[k]]$gamma_prob_bar[burn_in:J, m * (i-1) + j],
                            ylab = "transition probability",
                            xlab = "iteration", col = state_col[k])
          }
          graphics::title(main = paste("From state", i, "to State", j))
          graphics::legend("topright", col = state_col, legend = paste("Chain", 1:nchain),
                           bty = 'n', lty = 1, lwd = 2, cex = .8)
        }
      }

    }

    # if plotting emiss
  } else if (component == "emiss"){
    if (missing(cat_lab)){
      cat_lab <- paste("Category", 1:L[[1]]$input$q_emiss[dep])
    }
    if (missing(dep_lab)){
      dep_lab <- L[[1]]$input$dep_labels[dep]
    }
    # if ggplot2 and dplyr are available
    if(nzchar(system.file(package = "ggplot2")) && nzchar(system.file(package = "dplyr"))){

      # extract emission prob matrices
      object <- purrr::map_dfr(1:length(L), ~ {
        L[[.x]]$emiss_prob_bar[[dep]] %>% as.data.frame() %>% dplyr::mutate(iteration = dplyr::row_number()) %>% dplyr::slice(burn_in:J)
      } ,
      .id="chain") %>% tidyr::pivot_longer(!c(chain, iteration), names_to = "states", values_to = "value")
      # create traceplots
      if (nchain <= 1) {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value))
      } else {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value, colour = as.factor(chain)))
      }
      f <- f + ggplot2::geom_line(alpha=0.7) +
        ggplot2::scale_colour_discrete(name="Chain") +
        ggplot2::facet_wrap(~ states, ncol=1, scales="free") +
        ggplot2::labs(title = dep_lab, y = "")

      # if ggplot2 is not available, use baseR
    } else {
      # specify layout
      graphics::par(mfrow = c(m * q_emiss[dep], 1))

      f <- for(i in 1:m){
        # find min and max y
        maxy <- miny <- 0
        for(q in 1:q_emiss[dep]){
          newmax <- max(sapply(L, function(x) max(x$emiss_prob_bar[[dep]][burn_in:J,
                                                                          q_emiss[dep] * (i-1) + q])))
          newmin <- min(sapply(L, function(x) min(x$emiss_prob_bar[[dep]][burn_in:J,
                                                                          q_emiss[dep] * (i-1) + q])))
          if(newmax > maxy) maxy <- newmax
          if(newmin < miny) miny <- newmin
        }
        for(q in 1:q_emiss[dep]){
          graphics::plot.default(x = 1, ylim = c(miny, maxy), xlim = c(burn_in, J), type = "n", cex = .8,
                                 ylab = "emission probability", xlab = "iteration")
          for(k in 1:nchain){
            graphics::lines(x = burn_in:J, y = L[[k]]$emiss_prob_bar[[dep]][burn_in:J, (i-1) * q_emiss[dep] +q], col = state_col[k])
          }
          graphics::title(main = paste(dep_lab, cat_lab[q], "in State", i))
          graphics::legend("topright", col = state_col, legend = paste("Chain", 1:nchain),
                           bty = 'n', lty = 1, lwd = 2, cex = .8)
        }
      }

    }
  }

  return(f)
}
