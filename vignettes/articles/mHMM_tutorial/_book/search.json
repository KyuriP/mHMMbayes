[
  {
    "objectID": "prior.html#how-to-specify-prior-distributions",
    "href": "prior.html#how-to-specify-prior-distributions",
    "title": "7  Prior distributions",
    "section": "\n7.1 How to specify prior distributions",
    "text": "7.1 How to specify prior distributions\nTo specify user specific prior distributions, one uses the input option emiss_hyp_prior for the emission distribution and gamma_hyp_prior for the transition probabilities in the function mHMM. These input arguments take an object from the class mHMM_prior_emiss and mHMM_prior_gamma created by the functions prior_emiss_cat and prior_gamma, respectively. Both objects are a list, containing the following key elements:\n\n\nmu0, a lists containing the hypothesized hyper-prior mean values of the intercepts of the Multinomial logit model.\n\nK0, the number of hypothetical prior subjects on which the set of hyper-prior mean intercepts specified in mu0 are based.\n\nnu, degrees of freedom of the hyper-prior Inverse Wishart distribution on the covariance of the Multinomial logit intercepts.\n\nV, the variance-covariance of the hyper-prior Inverse Wishart distribution on the covariance of the Multinomial logit intercepts.\n\nNote that K0, nu and V are assumed equal over the states. The mean values of the intercepts (and regression coefficients of the covariates) denoted by mu0 are allowed to vary over the states. All elements in the list either have the prefix gamma_ or emiss_, depending on which list they belong to.\n\n\n\n\n\n\nCaution\n\n\n\nWhen specifying prior distributions, note that the first element of each row in the probability domain does not have an intercept, as it serves as baseline category in the Multinomial logit regression model.\nThis means, for example, that if we would specify a model with 3 states, mu0 is a vector with 2 elements, K0 and nu contain 1 element and V is a 2 by 2 matrix.\n\n\n\n7.1.1 Hyper-prior on transition probability matrix\nWhen using the prior_gamma function to specify informative hyper-prior on gamma, and if the hyper-prior values for gamma_K0, gamma_nu and gamma_V are not manually specified, the default values are as follows:\n\n\ngamma_K0 is set to \\(1\\).\n\ngamma_nu is set to \\(3 + m- 1\\).\nthe diagonal elements of gamma_V (i.e., the variance) are set to \\(3 + m - 1\\), while the off-diagonal elements (i.e., the covariance) are set to 0.\n\nThus, the user only needs to specify the number of states m and the hypothesized hyper-prior mean values of the multinomial logit intercepts, as default values are available for all other hyper-prior distribution parameters. The following code snippet provides an example of how to specify these values.\n\n# 1. specify general model properties\nm <- 3\n\n# 2. represent a prior belief: switching to state 3 does not occur often \n# and state 3 has a relative short duration\nprior_prob_gamma <- matrix(c(0.70, 0.25, 0.05,\n                             0.25, 0.70, 0.05,\n                             0.30, 0.30, 0.40), nrow = m, ncol = m, byrow = TRUE)\n\n# 3. use the function prob_to_int() to obtain intercept values for the \n# above specified transition probability matrix gamma\nprior_int_gamma <- prob_to_int(prior_prob_gamma)\ngamma_mu0 <- list(matrix(prior_int_gamma[1,], nrow = 1, ncol = m-1),\n                  matrix(prior_int_gamma[2,], nrow = 1, ncol = m-1),\n                  matrix(prior_int_gamma[3,], nrow = 1, ncol = m-1))\n\n# 4. feed them to the function prior_gamma()\nmanual_prior_gamma <- prior_gamma(m = m, gamma_mu0 = gamma_mu0)\n\n# 5. use the informative hyper-prior when fitting a model using the function mHHM()\n# mHHM(s_data = ..., ..., gamma_hyp_prior = manual_prior_gamma)\n\n\n\n\n\n\n\nNote\n\n\n\nWhen no manual values for the hyper-prior on gamma are specified at all (that is, the function prior_gamma is not used), all elements of the matrices contained in gamma_mu0 are set to 0 in the function mHMM.\n\n\n\n7.1.2 Hyper-prior on categorical emission distribution(s)\nWhen using the prior_emiss_cat function to specify informative hyper-prior on the categorical emission distirbution(s), and if the hyper-prior values for emiss_K0, emiss_nu and emiss_V are not manually specified, the default values are as follows:\n\n\nemiss_K0 is set to \\(1\\).\n\nemiss_nu is set to \\(3 + q\\_emiss[k] - 1\\).\nthe diagonal elements of emiss_V (i.e., the variance) are set to \\(3 + q\\_emiss[k] - 1\\), while the off-diagonal elements (i.e., the covariance) are set to 0.\n\nSimilarly to the transition probabilities above, if no manual values for the hyper-prior on the categorical emission distribution are specified at all (i.e., the function prior_emiss_cat is not used), all elements of the matrices contained in emiss_mu0 are set to 0 in the function mHMM. The following example code demonstrates how to specify the hyper-prior on emission distributions using the prior_emiss_cat function.\n\n# 1. specify general model properties\n m <- 3\n n_dep <- 4\n q_emiss <- c(3, 2, 3, 2)\n\n# 2. specify hypothesized mean emission probabilities\n prior_prob_emiss_cat <- list(matrix(c(0.10, 0.80, 0.10,\n                                       0.80, 0.10, 0.10,\n                                       0.40, 0.40, 0.20), byrow = TRUE,\n                                     nrow = m, ncol = q_emiss[1]), # vocalizing patient,\n                                     # prior belief: state 1 - much talking, state 2 -\n                                     # no talking, state 3 - mixed\n                              matrix(c(0.30, 0.70,\n                                       0.30, 0.70,\n                                       0.30, 0.70), byrow = TRUE, nrow = m,\n                                     ncol = q_emiss[2]), # looking patient\n                                     # prior belief: all 3 states show frequent looking\n                                     # behavior\n                              matrix(c(0.80, 0.10, 0.10,\n                                       0.10, 0.80, 0.10,\n                                       0.40, 0.40, 0.20), byrow = TRUE,\n                                     nrow = m, ncol = q_emiss[3]), # vocalizing therapist\n                                     # prior belief: state 1 - no talking, state 2 -\n                                     # frequent talking, state 3 - mixed\n                              matrix(c(0.30, 0.70,\n                                       0.30, 0.70,\n                                       0.30, 0.70), byrow = TRUE, nrow = m,\n                                     ncol = q_emiss[4])) # looking therapist\n                                     # prior belief: all 3 states show frequent looking\n                                     # behavior\n\n# 3. use the function prob_to_int() to obtain intercept values for the above specified\n# categorical emission distributions\n prior_int_emiss <- sapply(prior_prob_emiss_cat, prob_to_int)\n emiss_mu0 <- rep(list(vector(mode = \"list\", length = m)), n_dep)\n for(k in 1:n_dep){\n   for(i in 1:m){\n     emiss_mu0[[k]][[i]] <- matrix(prior_int_emiss[[k]][i,], nrow = 1)\n   }\n }\n\n# 4. feed them to the function prior_emiss_cat()\nmanual_prior_emiss <- prior_emiss_cat(gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),\n                                       emiss_mu0 = emiss_mu0)\n\n# 5. use the informative hyper-prior when fitting a model using the function mHHM()\n# mHHM(s_data = ..., ..., emiss_hyp_prior = manual_prior_emiss)\n\n\n\n\n\n\n\nNote\n\n\n\nIn case covariates are specified, the hyper-prior parameter values of the inverse Wishart distribution on the covariance matrix remain unchanged, as the estimates of the regression coefficients for the covariates are fixed over subjects."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "1  Preface",
    "section": "",
    "text": "Hidden Markov models [HMMs; Rabiner (1989)] are a machine learning method that have been used in many different scientific fields to describe a sequence of observations for several decades. For example, translating a fragment of spoken words into text (i.e., speech recognition, see e.g. Rabiner 1989; Woodland and Povey 2002), or the identification of the regions of DNA that encode genes (i.e., gene tagging, see e.g., Krogh, Mian, and Haussler 1994; Henderson, Salzberg, and Fasman 1997; Burge and Karlin 1998). The development of this package is, however, motivated from the area of social sciences. Due to technological advancements, it becomes increasingly easy to collect long sequences of data on behavior. That is, we can monitor behavior as it unfolds in real time. An example here of is the interaction between a therapist and a patient, where different types of nonverbal communication are registered every second for a period of 15 minutes. When applying HMMs to such behavioral data, they can be used to extract latent behavioral states over time, and model the dynamics of behavior over time.\n\nA quite recent development in HMMs is the extension to multilevel HMMs (see e.g., Altman 2007; Shirley et al. 2010; Rueda, Rueda, and Diaz-Uriarte 2013; Zhang and Berhane 2014; Haan-Rietdijk et al. 2017). Using the multilevel framework, we can model several sequences (e.g., sequences of different persons) simultaneously, while accommodating the heterogeneity between persons. As a result, we can quantify the amount of variation between persons in their dynamics of behavior, easily perform group comparisons on the model parameters, and investigate how model parameters change as a result of a covariate. For example, are the dynamics between a patient and a therapist different for patients with a good therapeutic outcome and patients with a less favorable therapeutic outcome?\n\nWith the package mHMMbayes, one can estimate these multilevel hidden Markov models. This tutorial starts out with a brief description of the HMM and the multilevel HMM. For a more elaborate and gentle introduction to HMMs, we refer to Zucchini, MacDonald, and Langrock (2016). Next, we show how to use the package mHMMbayes through an extensive example, also touching on the issues of determining the number of hidden states and checking model convergence. Information on the used estimation methods and algorithms in the package is given in the vignette Estimation of the multilevel hidden Markov model.\n\n\n\n\nAltman, Rachel MacKay. 2007. “Mixed Hidden Markov Models: An Extension of the Hidden Markov Model to the Longitudinal Data Setting.” Journal of the American Statistical Association 102 (477): 201–10.\n\n\nBurge, Christopher B, and Samuel Karlin. 1998. “Finding the Genes in Genomic DNA.” Current Opinion in Structural Biology 8 (3): 346–54.\n\n\nHaan-Rietdijk, S de, Peter Kuppens, Cindy S Bergeman, LB Sheeber, NB Allen, and EL Hamaker. 2017. “On the Use of Mixed Markov Models for Intensive Longitudinal Data.” Multivariate Behavioral Research 52 (6): 747–67.\n\n\nHenderson, John, Steven Salzberg, and Kenneth H Fasman. 1997. “Finding Genes in DNA with a Hidden Markov Model.” Journal of Computational Biology 4 (2): 127–41.\n\n\nKrogh, Anders, I Saira Mian, and David Haussler. 1994. “A Hidden Markov Model That Finds Genes in e. Coli DNA.” Nucleic Acids Research 22 (22): 4768–78.\n\n\nRabiner, Lawrence R. 1989. “A Tutorial on Hidden Markov Models and Selected Applications in Speech Recognition.” Proceedings of the IEEE 77 (2): 257–86.\n\n\nRueda, Oscar M, Cristina Rueda, and Ramon Diaz-Uriarte. 2013. “A Bayesian HMM with Random Effects and an Unknown Number of States for DNA Copy Number Analysis.” Journal of Statistical Computation and Simulation 83 (1): 82–96.\n\n\nShirley, Kenneth E, Dylan S Small, Kevin G Lynch, Stephen A Maisto, and David W Oslin. 2010. “Hidden Markov Models for Alcoholism Treatment Trial Data.” The Annals of Applied Statistics, 366–95.\n\n\nWoodland, Philip C, and Daniel Povey. 2002. “Large Scale Discriminative Training of Hidden Markov Models for Speech Recognition.” Computer Speech & Language 16 (1): 25–47.\n\n\nZhang, Yue, and Kiros Berhane. 2014. “Bayesian Mixed Hidden Markov Models: A Multi-Level Approach to Modeling Categorical Outcomes with Differential Misclassification.” Statistics in Medicine 33 (8): 1395–1408.\n\n\nZucchini, Walter, Iain L MacDonald, and Roland Langrock. 2016. Hidden Markov Models for Time Series: An Introduction Using R. Boca Raton: CRC Press."
  },
  {
    "objectID": "HMM.html",
    "href": "HMM.html",
    "title": "2  Hidden Markov models",
    "section": "",
    "text": "Hidden Markov Models are used for data for which 1) we believe that the distribution generating the observation depends on the state of an underlying, hidden state, and 2) the hidden states follow a Markov process, i.e., the states over time are not independent of one another, but the current state depends on the previous state only (and not on earlier states) (see e.g., Rabiner 1989; Ephraim and Merhav 2002; Cappé 2005; Zucchini, MacDonald, and Langrock 2016). The HMM is a discrete time model: for each point in time \\(t\\), we have one hidden state that generates one observed event for that time point \\(t\\).\nHence, the probability of observing the current outcome \\(O_t\\) is exclusively determined by the current latent state \\(S_t\\):\n\\[\\begin{equation}\nPr(O_{t} \\mid \\ O_{t-1}, O_{t-2}, \\ldots, O_{1}, \\ S_{t}, S_{t-1}, \\ldots, S_{1}) = Pr(O_{t} \\mid S_{t}).\n\\end{equation}\\]\nThe probability of observing \\(O_t\\) given \\(S_t\\) can have any distribution, e.g., discrete or continuous. In the current version of the package mHMMbayes, only the categorical emission distribution is implemented.\nThe hidden states in the sequence take values from a countable finite set of states \\(S_t = i, i \\in \\{1, 2, \\ldots, m\\}\\), where \\(m\\) denotes the number of distinct states, that form the Markov chain, with the Markov property:\n\\[\\begin{equation}\nPr(S_{t+1} \\mid \\ S_{t}, S_{t-1}, \\ldots, S_{1}) = Pr(S_{t+1} \\mid S_{t}).\n\\end{equation}\\]\nThat is, the probability of switching to the next state \\(S_{t+1}\\) depends only on the current state \\(S_t\\). As the HMM is a discrete time model, the duration of a state is represented by the self-transition probabilities \\(\\gamma_{ii}\\), where the probability of a certain time t spent in state \\(S\\) is given by the geometric distribution: \\(\\gamma_{ii}^{t-1}(1-\\gamma_{ii})\\).\nThe HMM includes three sets of parameters: the initial probabilities of the states \\(\\pi_i\\), the matrix \\(\\mathbf{\\Gamma}\\) including the transition probabilities \\(\\gamma_{ij}\\) between the states, and the state-dependent probability distribution of observing \\(O_t\\) given \\(S_t\\) with parameter set \\(\\boldsymbol{\\theta}_i\\). The initial probabilities \\(\\pi_i\\) denote the probability that the first state in the hidden state sequence, \\(S_1\\), is \\(i\\):\n\\[\\begin{equation}\n\\pi_i = Pr(S_1 = i) \\quad \\text{with} \\sum_i \\pi_i = 1.\n\\end{equation}\\]\nOften, the initial probabilities of the states \\(\\pi_i\\) are assumed to be the stationary distribution implied by the transition probability matrix \\(\\mathbf{\\Gamma}\\), that is, the long term steady-state probabilities obtained by \\(\\lim_{T \\rightarrow \\infty} \\mathbf{\\Gamma}^T\\). The transition probability matrix \\(\\mathbf{\\Gamma}\\) with transition probabilities \\(\\gamma_{ij}\\) denote the probability of switching from state \\(i\\) at time \\(t\\) to state \\(j\\) at time \\(t+1\\):\n\\[\\begin{equation}\n\\gamma_{ij} = Pr(S_{t+1} = j \\mid S_{t} = i) \\quad \\text{with} \\sum_j \\gamma_{ij} = 1.\n\\end{equation}\\]\nThat is, the transition probabilities \\(\\gamma_{ij}\\) in the HMM represent the probability to switch between hidden states rather than between observed acts, as in the MC and CTMC model. The state-dependent probability distribution denotes the probability of observing \\(O_t\\) given \\(S_t\\) with parameter set \\(\\boldsymbol{\\theta}_i\\). In case of the package, the state-dependent probability distribution is given by the categorical distribution, and the parameter set \\(\\boldsymbol{\\theta}_i\\) is the set of state-dependent probabilities of observing categorical outcomes. That is,\n\\[\\begin{equation}\nPr(O_t = o \\mid S_t = i) \\sim \\text{Cat} (\\boldsymbol{\\theta}_i),\n\\end{equation}\\]\nfor the observed outcomes \\(o = 1, 2, \\ldots, q\\) and where \\(\\boldsymbol{\\theta}_i = (\\theta_{i1}, \\theta_{i2}, \\ldots, \\theta_{iq})\\) is a vector of probabilities for each state \\(S = i, \\ldots, m\\) with \\(\\sum \\theta_i = 1\\), i.e., within each state, the probabilities of all possible outcomes sum up to 1.\nWe assume that all parameters in the HMM are independent of \\(t\\), i.e., we assume a time-homogeneous model. In the vignette Estimation of the multilevel hidden Markov model we discuss three methods (i.e., Maximum likelihood, Expectation Maximization or Baum-Welch algorithm, and Bayesian estimation) to estimate the parameters of an HMM. In the package mHMMbayes, we chose to use Bayesian estimation because of its flexibility, which we will require in the multilevel framework of the model.\n\n\n\n\nCappé, E. AND Rydén, O. AND Moulines. 2005. Inference in Hidden Markov Models. New York: Springer.\n\n\nEphraim, Yariv, and Neri Merhav. 2002. “Hidden Markov Processes.” Information Theory, IEEE Transactions on 48 (6): 1518–69.\n\n\nRabiner, Lawrence R. 1989. “A Tutorial on Hidden Markov Models and Selected Applications in Speech Recognition.” Proceedings of the IEEE 77 (2): 257–86.\n\n\nZucchini, Walter, Iain L MacDonald, and Roland Langrock. 2016. Hidden Markov Models for Time Series: An Introduction Using R. Boca Raton: CRC Press."
  },
  {
    "objectID": "mHMM.html",
    "href": "mHMM.html",
    "title": "3  Multilevel hidden Markov models",
    "section": "",
    "text": "Given data of multiple subjects, one may fit the HMM to the data of each subject separately, or fit one and the same HMM model to the data of all subject, under the strong (generally untenable) assumption that the subjects do not differ with respect to the parameters of the HMM. Fitting a different model to each behavioral sequence is not parsimonious, computationally intensive, and results in a large number of parameters estimates. Neither approach lends itself well for a formal comparison (e.g., comparing the parameters over experimental conditions). To facilitate the analysis of multiple subjects, the HMM is extended by putting it in a multilevel framework.\n\nIn multilevel models, model parameters are specified that pertain to different levels in the data. For example, subject-specific model parameters describe the data collected within each subject, and group level parameters describe what is typically observed within the group of subjects, and the variation observed between subjects. In the implemented multilevel HMM, we allow each subject to have its own unique parameter values within the same HMM model (i.e., identical number and similar composition of the hidden states). Rather than estimating these subject-specific parameters individually, we assume that the parameters of the HMM are random, i.e., follow a given group level distribution. Within this multilevel structure, the mean and the variance of the group level distribution of a given parameter thus expresses the overall mean parameter value in a group of subjects and the parameter variability between the subjects in the group.\n\nMultilevel HMMs have received some attention in the literature. In a frequentist context, Altman (2007) presented a general framework for HMMs for multiple processes by defining a class of Mixed Hidden Markov Models (MHMMs). These models are however, computationally intensive and due to slow convergence only suited for modeling a limited number of random effects. The approach of Altman has been translated to the Bayesian framework, which proved much faster as the time to reach convergence is decreased Zhang and Berhane (2014). In addition, the HMM in a Bayesian context is easier to adapt to a multilevel model, as the need for numerical integration is eliminated. Examples of the application of the multilevel HMM (within a Bayesian framework) are: Rueda, Rueda, and Diaz-Uriarte (2013) applied the model to the analysis of DNA copy number data, Zhang and Berhane (2014) to identify risk factors for asthma, Shirley et al. (2010) to clinical trial data of a treatment for alcoholism and Haan-Rietdijk et al. (2017) to longitudinal data sets in psychology.\n\nIn the tutorial, we use the following notation for the parameters in the multilevel HMM. The subject specific parameters are supplemented with the prefix \\(k\\), denoting subject \\(k \\in \\{1,2,\\ldots,K\\}\\). Hence, in the multilevel (Bayesian) HMM, the subject specific parameters are:\n\nthe subject-specific transition probability matrix \\(\\boldsymbol{\\Gamma}_k\\) with transition probabilities \\(\\gamma_{k,ij}\\)\nthe subject-specific emission distributions denoting subject-specific probabilities. \\(\\boldsymbol{\\theta}_{k,i}\\) of categorical outcomes within hidden state \\(i\\).\n\nThe group level parameters are:\n\nthe group level state transition probability matrix \\(\\boldsymbol{\\Gamma}\\) with transition probabilities \\(\\gamma_{ij}\\).\nthe group level state-dependent probabilities \\(\\boldsymbol{\\theta}_{i}\\).\n\n\n\n\n\n\n\nNote\n\n\n\nThe initial probabilities of the states \\(\\pi_{k,j}\\) are not estimated as \\(\\pi_{k}\\) is assumed to be the stationary distribution of \\(\\boldsymbol{\\Gamma}_k\\).\n\n\nWe fit the model using Bayesian estimation (i.e., a hybrid Metropolis Gibbs sampler that utilizes the forward-backward recursion to sample the hidden state sequence of each subject, see the vignette Estimation of the multilevel hidden Markov model).\n\n\n\n\nAltman, Rachel MacKay. 2007. “Mixed Hidden Markov Models: An Extension of the Hidden Markov Model to the Longitudinal Data Setting.” Journal of the American Statistical Association 102 (477): 201–10.\n\n\nHaan-Rietdijk, S de, Peter Kuppens, Cindy S Bergeman, LB Sheeber, NB Allen, and EL Hamaker. 2017. “On the Use of Mixed Markov Models for Intensive Longitudinal Data.” Multivariate Behavioral Research 52 (6): 747–67.\n\n\nRueda, Oscar M, Cristina Rueda, and Ramon Diaz-Uriarte. 2013. “A Bayesian HMM with Random Effects and an Unknown Number of States for DNA Copy Number Analysis.” Journal of Statistical Computation and Simulation 83 (1): 82–96.\n\n\nShirley, Kenneth E, Dylan S Small, Kevin G Lynch, Stephen A Maisto, and David W Oslin. 2010. “Hidden Markov Models for Alcoholism Treatment Trial Data.” The Annals of Applied Statistics, 366–95.\n\n\nZhang, Yue, and Kiros Berhane. 2014. “Bayesian Mixed Hidden Markov Models: A Multi-Level Approach to Modeling Categorical Outcomes with Differential Misclassification.” Statistics in Medicine 33 (8): 1395–1408."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "4  Data",
    "section": "",
    "text": "We illustrate using the mHMMbayes package using the embedded example data nonverbal. The data contains the nonverbal communication of 10 patient-therapist couples, recorded for 15 minutes at a frequency of 1 observation per second (= 900 observations per couple).\nThe following variables are contained in the dataset:\n\n\nid: id variable of patient - therapist couple to distinguish which observation belongs to which couple.\n\np_verbalizing: verbalizing behavior of the patient, consisting of 1 = not verbalizing, 2 = verbalizing, 3 = back channeling.\n\np_looking: looking behavior of the patient, consisting of 1 = not looking at therapist, 2 = looking at therapist.\n\nt_verbalizing: verbalizing behavior of the therapist, consisting of 1 = not verbalizing, 2 = verbalizing, 3 = back channeling.\n\nt_looking: looking behavior of the therapist, consisting of 1 = not looking at patient, 2 = looking at patient. The top 6 rows of the dataset are provided below.\n\n\nBelow is a glimpse of how the data appears.\n\n\n\n\n  id p_vocalizing p_looking t_vocalizing t_looking\n1  1            2         2            2         2\n2  1            2         2            1         2\n3  1            2         2            2         2\n4  1            2         2            2         2\n5  1            2         2            2         2\n6  1            2         2            1         2\n\n\n\nWhen we plot the data of the first 5 minutes (= the first 300 observations) of the first couple, we get the following:\n\n\n\n\n\nWe can, for example, observe that both the patient and the therapist are mainly looking at each other during the observed 5 minutes. During the first minute, the patient is primarily speaking. During the second minute, the therapists starts, after which the patient takes over while the therapist is back channeling."
  },
  {
    "objectID": "specification.html",
    "href": "specification.html",
    "title": "5  Model specification",
    "section": "",
    "text": "Let’s proceed with fitting a simple 2-state multilevel model using the mHMM function. First, we need to set some general model properties and starting values:\n\n# Load the mHMMbayes package \nlibrary(mHMMbayes)\n\n# Specify general model properties:\nm <- 2\nn_dep <- 4\nq_emiss <- c(3, 2, 3, 2)\n\n# Specify starting values for transition matrix (TM) and emission probabilities (EM)\nstart_TM <- diag(.8, m)\nstart_TM[lower.tri(start_TM) | upper.tri(start_TM)] <- .2\nstart_EM <- list(matrix(c(0.05, 0.90, 0.05, \n                          0.90, 0.05, 0.05), byrow = TRUE,\n                         nrow = m, ncol = q_emiss[1]), # vocalizing patient\n                  matrix(c(0.1, 0.9, \n                           0.1, 0.9), byrow = TRUE, nrow = m,\n                         ncol = q_emiss[2]), # looking patient\n                  matrix(c(0.90, 0.05, 0.05, \n                           0.05, 0.90, 0.05), byrow = TRUE,\n                         nrow = m, ncol = q_emiss[3]), # vocalizing therapist\n                  matrix(c(0.1, 0.9, \n                           0.1, 0.9), byrow = TRUE, nrow = m,\n                         ncol = q_emiss[4])) # looking therapist\n\nThe first line of code loads the mHMMbayes package and the nonverbal data.\nThen, we specify the general model properties:\n\nthe number of states used is set by m <- 2.\nthe number of dependent variables in the dataset used to infer the hidden states is specified by n_dep <- 4.\nthe number of categorical outcomes for each of the dependent variables is specified by q_emiss <- c(3, 2, 3, 2).\n\nThe subsequent lines of code specify the starting values for the transition probability matrix (start_TM) and the emission distributions (start_EM). Next, we will delve into more detail on how to specify these starting values."
  },
  {
    "objectID": "startingval.html",
    "href": "startingval.html",
    "title": "6  Starting values",
    "section": "",
    "text": "Previously in Chapter 4, we specified the starting values for the transition probability matrix (start_TM) and the emission distributions (start_EM), which are given to the model in the argument start_val (see the code snippet provided in Chapter 7).\nThese starting values are used for the first run of the forward backward algorithm. Although the hidden states cannot be observed, one often has an idea for probable compositions of the states.\nIn this example, we expect that there is a state in which the patient mostly speaks, and the therapist is silent, and a state during which the patient is silent and the therapists speaks. In addition, we expect that during both states, the therapist and the patient will be mainly looking at each other instead of looking away. Below in Table 6.1, we illustrate how these expectations can be specified.\n\n\nTable 6.1: Starting values for emission distributions\n\n\n\n\n(a) vocalizing patient\n\n\n\nNot Speaking\nSpeaking\nBack channeling\n\n\n\n\nState1\n0.05\n0.90\n0.05\n\n\nState2\n0.90\n0.05\n0.05\n\n\n\n\n\n\n(b) vocalizing therapist\n\n\n\nNot Speaking\nSpeaking\nBack channeling\n\n\n\n\nState1\n0.90\n0.05\n0.05\n\n\nState2\n0.05\n0.90\n0.05\n\n\n\n\n\n\n\n\n(c) looking patient\n\n\n\nNot looking\nLooking\n\n\n\n\nState1\n0.1\n0.9\n\n\nState2\n0.1\n0.9\n\n\n\n\n\n\n(d) looking therapist\n\n\n\nNot looking\nLooking\n\n\n\n\nState1\n0.1\n0.9\n\n\nState2\n0.1\n0.9\n\n\n\n\n\n\nOne usually also has some (vague) idea on likely and unlikely switches between states, and the size of self-transition probabilities. In this example, we think a state will usually last quite some seconds, and thus expect a rather high self-transition probability. Below in Table 6.2, we illustrate how these expectations can be specified.\n\n\nTable 6.2: Starting values for transition probabilities\n\n\n\nState1\nState2\n\n\n\n\nState1\n0.8\n0.2\n\n\nState2\n0.2\n0.8\n\n\n\n\nAll these ideas can be used to construct a set of sensible starting values. Using sensible starting values increases convergence speed, and often prevents a problem called label switching. Hence, using random or uniform starting values is not recommended, and a default option to do so is not included in the package.\n\n\n\n\n\n\nNote\n\n\n\nNote that it is strongly advised to check model convergence and label switching. That is, one should check if the algorithm reaches the same solution when a set of different (but often conceptually similar) starting values are used, and if label switching is not a problem. See the section Chapter 12 for an example. See the vignette Estimation of the multilevel hidden Markov model for more information on the forward backward algorithm and on the problem of label switching."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Altman, Rachel MacKay. 2007. “Mixed Hidden Markov\nModels: An Extension of the Hidden Markov Model to the\nLongitudinal Data Setting.” Journal of the American\nStatistical Association 102 (477): 201–10.\n\n\nBurge, Christopher B, and Samuel Karlin. 1998. “Finding the Genes\nin Genomic DNA.” Current Opinion in Structural Biology 8\n(3): 346–54.\n\n\nCappé, E. AND Rydén, O. AND Moulines. 2005. Inference in Hidden\nMarkov Models. New York: Springer.\n\n\nEphraim, Yariv, and Neri Merhav. 2002. “Hidden Markov\nProcesses.” Information Theory, IEEE Transactions on 48\n(6): 1518–69.\n\n\nHaan-Rietdijk, S de, Peter Kuppens, Cindy S Bergeman, LB Sheeber, NB\nAllen, and EL Hamaker. 2017. “On the Use of Mixed Markov Models\nfor Intensive Longitudinal Data.” Multivariate Behavioral\nResearch 52 (6): 747–67.\n\n\nHenderson, John, Steven Salzberg, and Kenneth H Fasman. 1997.\n“Finding Genes in DNA with a Hidden Markov Model.”\nJournal of Computational Biology 4 (2): 127–41.\n\n\nKrogh, Anders, I Saira Mian, and David Haussler. 1994. “A Hidden\nMarkov Model That Finds Genes in e. Coli DNA.” Nucleic Acids\nResearch 22 (22): 4768–78.\n\n\nRabiner, Lawrence R. 1989. “A Tutorial on Hidden\nMarkov Models and Selected Applications in Speech\nRecognition.” Proceedings of the IEEE 77 (2): 257–86.\n\n\nRueda, Oscar M, Cristina Rueda, and Ramon Diaz-Uriarte. 2013. “A\nBayesian HMM with Random Effects and an\nUnknown Number of States for DNA Copy Number\nAnalysis.” Journal of Statistical Computation and\nSimulation 83 (1): 82–96.\n\n\nShirley, Kenneth E, Dylan S Small, Kevin G Lynch, Stephen A Maisto, and\nDavid W Oslin. 2010. “Hidden Markov Models for\nAlcoholism Treatment Trial Data.” The Annals of Applied\nStatistics, 366–95.\n\n\nWoodland, Philip C, and Daniel Povey. 2002. “Large Scale\nDiscriminative Training of Hidden Markov Models for Speech\nRecognition.” Computer Speech & Language 16 (1):\n25–47.\n\n\nZhang, Yue, and Kiros Berhane. 2014. “Bayesian Mixed Hidden\nMarkov Models: A Multi-Level Approach to Modeling\nCategorical Outcomes with Differential Misclassification.”\nStatistics in Medicine 33 (8): 1395–1408.\n\n\nZucchini, Walter, Iain L MacDonald, and Roland Langrock. 2016.\nHidden Markov Models for Time Series: An Introduction\nUsing R. Boca Raton: CRC Press."
  },
  {
    "objectID": "fittingmodel.html",
    "href": "fittingmodel.html",
    "title": "8  Fitting the model",
    "section": "",
    "text": "The multilevel Hidden Markov Model (HMM) is fitted using the function mHMM. Below, we demonstrate how to fit a model without any covariates and with default priors.\n\n# Run a model without covariate(s) and with default priors\nset.seed(14532)\nout_2st <- mHMM(s_data = nonverbal, \n                    gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss), \n                    start_val = c(list(start_TM), start_EM),\n                    mcmc = list(J = 1000, burn_in = 200))\n\nThe call to mHMM specifies the model with several arguments.\n\ns_data argument specifies the input data used to infer the hidden states over time.\ngen and start_val arguments specify the general model properties and the starting values, as discussed previously in Chapter 5 and Chapter 6.\n\nThe arguments needed for the MCMC algorithm are given in mcmc:\n\n\nJ specifies the number of iterations used by the hybrid metropolis within Gibbs algorithm.\n\nburn_in specifies the number of iterations to discard when obtaining the model parameter summary statistics.\n\n\n\nThe function mHMM returns an object of class mHMM, and you can use the print and summary methods to view the results. The print method provides essential information about the fitted model, including the number of subjects in the dataset, the number of iterations performed, the burn-in period, the average log likelihood across all subjects, and model fit indices such as AIC. Additionally, it displays the number of states specified and the number of dependent variables used for modeling the states. The information displayed is as follow.\n\nprint(out_2st)\n\n#> Number of subjects: 10 \n#> \n#> 1000 iterations used in the MCMC algorithm with a burn in of 200 \n#> Average Log likelihood over all subjects: -1624.389 \n#> Average AIC over all subjects: 3276.777 \n#> \n#> Number of states used: 2 \n#> \n#> Number of dependent variables used: 4\n\n\nThe summary method provides information on the estimated parameters. That is, the point estimates of the posterior distribution for the transition probability matrix and the emission distribution of each of the dependent variables at the group level, as shown below.\n\nsummary(out_2st)\n\n#> State transition probability matrix \n#>  (at the group level): \n#>  \n#>              To state 1 To state 2\n#> From state 1      0.929      0.071\n#> From state 2      0.074      0.926\n#> \n#>  \n#> Emission distribution for each of the dependent variables \n#>  (at the group level): \n#>  \n#> $p_vocalizing\n#>         Category 1 Category 2 Category 3\n#> State 1      0.018      0.957      0.024\n#> State 2      0.795      0.052      0.153\n#> \n#> $p_looking\n#>         Category 1 Category 2\n#> State 1      0.248      0.752\n#> State 2      0.096      0.904\n#> \n#> $t_vocalizing\n#>         Category 1 Category 2 Category 3\n#> State 1      0.806      0.075      0.119\n#> State 2      0.034      0.945      0.020\n#> \n#> $t_looking\n#>         Category 1 Category 2\n#> State 1      0.047      0.953\n#> State 2      0.277      0.723\n\n\nThe resulting model indicates two well-separated states: one where the patient is speaking and another where the therapist is speaking. The looking behavior is quite similar for both the patient and the therapist in these two states. To obtain information on the estimated parameters, you can also use the functions obtain_gamma and obtain_emiss. These functions not only allow you to inspect the estimated parameters at the group level but also provide individual subject-level information by specifying the input variable level = \"subject\":\n\n# When not specified, level defaults to \"group\"\ngamma_pop <- obtain_gamma(out_2st)\ngamma_pop\n\n#>              To state 1 To state 2\n#> From state 1      0.929      0.071\n#> From state 2      0.074      0.926\n\n\n\n# To obtain the subject specific parameter estimates:\ngamma_subj <- obtain_gamma(out_2st, level = \"subject\")\ngamma_subj\n\n\nSee the list of subject-specific parameter estimates: gamma_subj\n\n\n#> $`Subject 1`\n#>              To state 1 To state 2\n#> From state 1      0.942      0.058\n#> From state 2      0.048      0.952\n#> \n#> $`Subject 2`\n#>              To state 1 To state 2\n#> From state 1      0.936      0.064\n#> From state 2      0.060      0.940\n#> \n#> $`Subject 3`\n#>              To state 1 To state 2\n#> From state 1      0.969      0.031\n#> From state 2      0.054      0.946\n#> \n#> $`Subject 4`\n#>              To state 1 To state 2\n#> From state 1      0.934      0.066\n#> From state 2      0.046      0.954\n#> \n#> $`Subject 5`\n#>              To state 1 To state 2\n#> From state 1      0.942      0.058\n#> From state 2      0.058      0.942\n#> \n#> $`Subject 6`\n#>              To state 1 To state 2\n#> From state 1      0.942      0.058\n#> From state 2      0.087      0.913\n#> \n#> $`Subject 7`\n#>              To state 1 To state 2\n#> From state 1      0.929      0.071\n#> From state 2      0.043      0.958\n#> \n#> $`Subject 8`\n#>              To state 1 To state 2\n#> From state 1       0.93      0.070\n#> From state 2       0.08      0.919\n#> \n#> $`Subject 9`\n#>              To state 1 To state 2\n#> From state 1      0.948      0.052\n#> From state 2      0.058      0.942\n#> \n#> $`Subject 10`\n#>              To state 1 To state 2\n#> From state 1      0.960      0.040\n#> From state 2      0.068      0.932\n\n\n\n\n\n\n\n\nTip\n\n\n\nAn additional option provided by the functions obtain_gamma and obtain_emiss is the ability to change the burn-in period used for obtaining the summary statistics. This can be done by specifying the input argument burn_in."
  },
  {
    "objectID": "plotting.html",
    "href": "plotting.html",
    "title": "9  Graphically displaying outcomes",
    "section": "",
    "text": "The package includes several plot functions to visualize the fitted model and its parameters. One can plot the posterior densities of a fitted model, for both the transition probability matrix gamma and for the emission distribution probabilities. These densities are displayed for both the group level and the subject level simultaneously. When the ggplot2 package is installed, the functions will utilize ggplot by default. However, if ggplot2 is not available, the base R plot function will be used instead.\nHere’s an example demonstrating how to create a plot of the emission distribution for the variable p_vocalizing:\n\nlibrary(RColorBrewer)\n# specify color and label\nVoc_col <- c(brewer.pal(3,\"PuBuGn\")[c(1,3,2)])\nVoc_lab <- c(\"Not Speaking\", \"Speaking\", \"Back channeling\")\n# use base R plot function\nplot(out_2st, component = \"emiss\", dep = 1, col = Voc_col, \n     dep_lab = c(\"Patient vocalizing\"), cat_lab = Voc_lab)\n\n\n\n\n\n\n\n\n# when ggplot2 is available\nlibrary(ggplot2)\nplot(out_2st, component = \"emiss\", dep = 1, col = Voc_col, \n     dep_lab = c(\"Patient vocalizing\"), cat_lab = Voc_lab)\n\n\n\n\n\n\n\n\n\nIn the plots above, the solid line visualizes the posterior density at the group level, while each of the dotted lines visualizes the posterior density of one subject.\n\n\n\n\n\n\nPlot Function Arguments\n\n\n\n\n\ncomponent specifies whether we want to visualize the posterior densities for the transition probability matrix gamma (component = \"gamma\") or for the emission distribution probabilities (component = \"emiss\").\nWhen using component = \"emiss\", the argument dep specifies which dependent variable we want to inspect. Here, we set dep = 1 as the variable p_vocolizing is the first variable in the set.\n\ncol specifies the colors to be used when plotting the lines.\n\ndep_lab denotes the label of the dependent variable we are plotting.\n\ncat_lab denotes the labels of the categorical outcomes in the corresponding dependent variable.\nFor more detailed information, check the help file of the function (?plot.mHMM).\n\n\n\nSecond, one can plot the transition probabilities obtained with the function obtain_gamma with a riverplot:\n\n# Transition probabilities at the group level and for subject number 1, respectively:\nplot(gamma_pop, col = rep(rev(brewer.pal(3,\"PiYG\"))[-2], each = m))\nplot(gamma_subj, subj_nr = 1, col = rep(rev(brewer.pal(3,\"PiYG\"))[-2], each = m))\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote that graphically displaying the transition probabilities becomes more informative as the number of states increase."
  },
  {
    "objectID": "plotting.html#plot.mhmm-function",
    "href": "plotting.html#plot.mhmm-function",
    "title": "9  Graphically displaying outcomes",
    "section": "\n9.1 plot.mHMM function",
    "text": "9.1 plot.mHMM function\nOne can plot the posterior densities of a fitted model, for both the transition probability matrix gamma and for the emission distribution probabilities. These densities are displayed for both the group level and the subject level simultaneously. When the ggplot2 package is installed, the functions will utilize ggplot by default. However, if ggplot2 is not available, the base R plot function will be used instead.\nHere’s an example demonstrating how to create a plot of the emission distribution for the variable p_vocalizing:\n\nlibrary(RColorBrewer)\n# specify color and label\nVoc_col <- c(brewer.pal(3,\"PuBuGn\")[c(1,3,2)])\nVoc_lab <- c(\"Not Speaking\", \"Speaking\", \"Back channeling\")\n# use base R plot function\nplot(out_2st, component = \"emiss\", dep = 1, col = Voc_col, \n     dep_lab = c(\"Patient vocalizing\"), cat_lab = Voc_lab)\n\n\n\n\n\n\n\n\n# when ggplot2 is available\nlibrary(ggplot2)\nplot(out_2st, component = \"emiss\", dep = 1, col = Voc_col, \n     dep_lab = c(\"Patient vocalizing\"), cat_lab = Voc_lab)\n\n\n\n\n\n\n\n\n\nIn the plots above, the solid line visualizes the posterior density at the group level, while each of the dotted lines visualizes the posterior density of one subject.\n\n\n\n\n\n\nPlot Function Arguments\n\n\n\n\n\ncomponent specifies whether we want to visualize the posterior densities for the transition probability matrix gamma (component = \"gamma\") or for the emission distribution probabilities (component = \"emiss\").\nWhen using component = \"emiss\", the argument dep specifies which dependent variable we want to inspect. Here, we set dep = 1 as the variable p_vocolizing is the first variable in the set.\n\ncol specifies the colors to be used when plotting the lines.\n\ndep_lab denotes the label of the dependent variable we are plotting.\n\ncat_lab denotes the labels of the categorical outcomes in the corresponding dependent variable.\nFor more detailed information, check the help file of the function (?plot.mHMM).\n\n\n\nSecond, one can plot the transition probabilities obtained with the function obtain_gamma with a riverplot:\n\n# Transition probabilities at the group level and for subject number 1, respectively:\nplot(gamma_pop, col = rep(rev(brewer.pal(3,\"PiYG\"))[-2], each = m))\nplot(gamma_subj, subj_nr = 1, col = rep(rev(brewer.pal(3,\"PiYG\"))[-2], each = m))\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote that graphically displaying the transition probabilities becomes more informative as the number of states increase."
  },
  {
    "objectID": "plotting.html#posterior-densities-plot",
    "href": "plotting.html#posterior-densities-plot",
    "title": "9  Graphically displaying outcomes",
    "section": "\n9.1 Posterior densities plot",
    "text": "9.1 Posterior densities plot\nOne can plot the posterior densities of a fitted model, for both the transition probability matrix gamma and for the emission distribution probabilities. These densities are displayed for both the group level and the subject level simultaneously. When the ggplot2 package is installed, the functions will utilize ggplot by default. However, if ggplot2 is not available, the base R plot function will be used instead.\nHere’s an example demonstrating how to create a plot of the emission distribution for the variable p_vocalizing:\n\nlibrary(RColorBrewer)\n# specify color and label\nVoc_col <- c(brewer.pal(3,\"PuBuGn\")[c(1,3,2)])\nVoc_lab <- c(\"Not Speaking\", \"Speaking\", \"Back channeling\")\n# use base R plot function\nplot(out_2st, component = \"emiss\", dep = 1, col = Voc_col, \n     dep_lab = c(\"Patient vocalizing\"), cat_lab = Voc_lab)\n\n\n\n\n\n\n\n\n# when ggplot2 is available\nlibrary(ggplot2)\nplot(out_2st, component = \"emiss\", dep = 1, col = brewer.pal(3, \"Accent\"),\n     dep_lab = c(\"Patient vocalizing\"), cat_lab = Voc_lab)\n\n\n\n\n\n\n\n\n\nIn the plots above, the solid line visualizes the posterior density at the group level, while each of the dotted lines visualizes the posterior density of one subject.\n\n\n\n\n\n\nPlot Function Arguments\n\n\n\n\n\ncomponent specifies whether we want to visualize the posterior densities for the transition probability matrix gamma (component = \"gamma\") or for the emission distribution probabilities (component = \"emiss\").\nWhen using component = \"emiss\", the argument dep specifies which dependent variable we want to inspect. Here, we set dep = 1 as the variable p_vocolizing is the first variable in the set.\n\ncol specifies the colors to be used when plotting the lines.\n\ndep_lab denotes the label of the dependent variable we are plotting.\n\ncat_lab denotes the labels of the categorical outcomes in the corresponding dependent variable.\nFor more detailed information, check the help file of the function (?plot.mHMM)."
  },
  {
    "objectID": "plotting.html#transition-probabilities-plot-riverplot",
    "href": "plotting.html#transition-probabilities-plot-riverplot",
    "title": "9  Graphically displaying outcomes",
    "section": "\n9.2 Transition probabilities plot (riverplot)",
    "text": "9.2 Transition probabilities plot (riverplot)\nAdditionally, the package provides a way to plot the transition probabilities obtained using the function obtain_gamma in the form of a riverplot. The visualization showcases the transitions between hidden states in a visually appealing manner. Just like with the other plot function above, this function will automatically choose between base R plot or ggplot functions based on the presence of the ggplot2 package in your R environment.\nBelow, we provide examples of how to create riverplots (when ggplot2 is available).\n\n# Transition probabilities at the group level\nplot(gamma_pop)\n# Transition probabilities for subject number 1:\nplot(gamma_subj, subj_nr = 1)\n\n\n\n\n\nFigure 9.1: At group level\n\n\n\n\n\n\nFigure 9.2: For subject number 1\n\n\n\n\n\n\nGraphically displaying the transition probabilities becomes more informative as the number of hidden states increases. See an example plot below that demonstrates this with four specified hidden states. As the number of states increases, the visual representation becomes more intricate!"
  },
  {
    "objectID": "hiddenstate.html",
    "href": "hiddenstate.html",
    "title": "10  Determining the number of hidden states",
    "section": "",
    "text": "The first step in developing a HMM is to determine the number of states \\(m\\) that best describes the observed data, and is a model selection problem. When modelling, for example, behavior, the task is to define the states by clusters of observed behavioral outcomes that provide a reasonable, theoretically interpretable, description of the data.\nWe suggest using a combination of the Akaike Information Criterion (AIC) and the theoretical interpretability of the estimated states to choose between models1. In the example dataset, the 2-, 3- and 4-state model result in an AIC of 3279, 3087, and 2959, respectively. According to model fit indices, the 4 -state model is clearly the best model2. Let’s inspect the composition of the states for the 4 state model, and the transition probabilities.\nWe can see that we have a state in which the patient speaks and the therapist is silent (state 1), a state in which the patient is silent and the therapist speaks (state 2), a state in which both the patient and therapist speak (state 3) and a state in which the therapist speaks but does not look at the patient (in contrast to the looking behavior in all other states), and the patient is silent. In addition, all states are quite stable as the probability of remaining in the same state is above .6 for all states.\n\nsummary(out_4st)\n\n#> State transition probability matrix \n#>  (at the group level): \n#>  \n#>              To state 1 To state 2 To state 3 To state 4\n#> From state 1      0.910      0.031      0.040      0.019\n#> From state 2      0.044      0.815      0.056      0.084\n#> From state 3      0.183      0.097      0.666      0.054\n#> From state 4      0.024      0.220      0.019      0.738\n#> \n#> Emission distribution for each of the dependent variables \n#>  (at the group level): \n#>  \n#> $p_vocalizing\n#>         Category 1 Category 2 Category 3\n#> State 1      0.011      0.976      0.013\n#> State 2      0.729      0.046      0.225\n#> State 3      0.184      0.665      0.150\n#> State 4      0.876      0.065      0.059\n#> \n#> $p_looking\n#>         Category 1 Category 2\n#> State 1      0.237      0.763\n#> State 2      0.061      0.939\n#> State 3      0.439      0.561\n#> State 4      0.094      0.906\n#> \n#> $t_vocalizing\n#>         Category 1 Category 2 Category 3\n#> State 1      0.889      0.013      0.097\n#> State 2      0.019      0.971      0.011\n#> State 3      0.332      0.593      0.074\n#> State 4      0.087      0.845      0.068\n#> \n#> $t_looking\n#>         Category 1 Category 2\n#> State 1      0.030      0.970\n#> State 2      0.045      0.955\n#> State 3      0.074      0.926\n#> State 4      0.949      0.051\n\nm <- 4\nplot(obtain_gamma(out_4st))\n\n\n\n\n\n\n\n\n\n\n\nRydén, Tobias. 2008. “EM Versus Markov Chain Monte Carlo for Estimation of Hidden Markov Models: A Computational Perspective.” Bayesian Analysis 3 (4): 659–88.\n\n\nScott, Steven L. 2002. “Bayesian Methods for Hidden Markov Models.” Journal of the American Statistical Association 97 (457).\n\n\n\n\nNote that the likelihood ratio test, commonly used to compare nested models, cannot be used in case of the HMM (i.e., the difference in the log-likelihoods between models is not \\(\\chi^2\\) distributed Rydén (2008)).↩︎\nWe note, however, that the AIC approximates the posterior distribution of the parameters by a Gaussian distribution, which might not be appropriate for models including parameters on the boundary of the parameter space (e.g., close to 0 or 1 in case of probability estimates), or for small data sets, as exemplified by Scott (2002). Model selection is therefore not a straightforward procedure in the context of HMM, and the choices remain subjective.↩︎"
  },
  {
    "objectID": "sequence.html",
    "href": "sequence.html",
    "title": "11  Determining the most likely state sequence",
    "section": "",
    "text": "Given a well-fitting HMM, it may be of interest to determine the actual sequence, or order of succession, of hidden states that has most likely given rise to the sequence of outcomes as observed in a subject. One can either use local decoding, in which the probabilities of the hidden state sequence are obtained simultaneously with the model parameters estimates, or the well-known Viterbi algorithm (Viterbi 1967; Forney Jr 1973). In local decoding, the most likely state is determined separately at each time point \\(t\\), in contrast to the Viterbi algorithm in which one determines the joint probability of the complete sequence of observations \\(O_{1:T}\\) and the complete sequence of hidden states \\(S_{1:T}\\).\nIn the package, local decoding can be achieved by saving the sampled hidden state sequence at each iteration of the Gibbs sampler, by setting the input variable return_path = TRUE for the function mHMM. This will result in very large output files, however. Global decoding can be performed by using the function vit_mHMM:\n\nstate_seq <- vit_mHMM(out_2st, s_data = nonverbal)\nhead(state_seq)\n\n#>      Subj_1 Subj_2 Subj_3 Subj_4 Subj_5 Subj_6 Subj_7 Subj_8 Subj_9 Subj_10\n#> [1,]      1      2      2      2      1      2      1      1      1       1\n#> [2,]      1      2      2      2      1      2      1      1      1       1\n#> [3,]      1      2      2      2      2      2      1      1      1       1\n#> [4,]      1      2      2      2      2      2      1      1      1       1\n#> [5,]      1      2      2      2      2      2      2      1      1       1\n#> [6,]      1      2      2      2      2      1      2      1      1       1\n\n\nThe function returns the hidden state sequence for each subject in a matrix, where each row represents a point in time and each column represents a subject. We can inspect the obtained hidden state sequence by for example plotting it together with the observed data. Below, the first 5 minutes of the first couple is plotted again, with the addition of the estimated state sequence:\n\n\n\n\n\n\n\n\n\n\n\n\nForney Jr, G David. 1973. “The Viterbi Algorithm.” Proceedings of the IEEE 61 (3): 268–78.\n\n\nViterbi, Andrew J. 1967. “Error Bounds for Convolutional Codes and an Asymptotically Optimum Decoding Algorithm.” Information Theory, IEEE Transactions on 13 (2): 260–69."
  },
  {
    "objectID": "convergence.html",
    "href": "convergence.html",
    "title": "12  Model convergence and label switching",
    "section": "",
    "text": "When using Bayesian estimation procedures, it is strongly advised to check model convergence and label switching. That is, one should check if the algorithm reaches the same solution when a set of different (but often conceptually similar) starting values are used, and if label switching is not a problem. With label switching, the label (i.e., which state represents what) ordering of the states switches over the iterations of the estimation algorithm. For example, what started out as state 1, now becomes state 2.\nOne can check model convergence and label switching visually by inspecting the trace plots of parameters of a set of identical models that used varying starting values. Trace plots are plots of the sampled parameter values over the iterations. First, we fit the model with 2 states again, but with different starting values:\n\n# specifying general model properties\nm <-2\nn_dep <- 4\nq_emiss <- c(3, 2, 3, 2)\n# specifying different starting values\nstart_TM <- diag(.8, m)\nstart_TM[lower.tri(start_TM) | upper.tri(start_TM)] <- .2\nstart_EM_b <- list(matrix(c(0.2, 0.6, 0.2,\n                            0.6, 0.2, 0.2), byrow = TRUE,\n                        nrow = m, ncol = q_emiss[1]), # vocalizing patient\n                 matrix(c(0.4, 0.6,\n                          0.4, 0.6), byrow = TRUE, nrow = m,\n                        ncol = q_emiss[2]), # looking patient\n                 matrix(c(0.6, 0.2, 0.2,\n                          0.2, 0.6, 0.2), byrow = TRUE,\n                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist\n                 matrix(c(0.4, 0.6,\n                          0.4, 0.6), byrow = TRUE, nrow = m,\n                        ncol = q_emiss[4])) # looking therapist\n\n# Run a model identical to out_2st, but with different starting values:\nset.seed(9843)\nout_2st_b <- mHMM(s_data = nonverbal, \n                      gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss), \n                      start_val = c(list(start_TM), start_EM),\n                      mcmc = list(J = 1000, burn_in = 200))\n\nThe group level parameter estimates of the emission probabilities and the transition probability matrix at each iteration of the estimation algorithm are stored in the objects emiss_prob_bar and gamma_prob_bar, respectively. The subject level parameter estimates are stored in the object PD_subj, where PD is an abbreviation for posterior density. If we, for example, want to inspect the trace plots for the emission probabilities for looking behavior of the patient at the group level, we use the following code:\n\npar(mfrow = c(m,q_emiss[2]))\nLook_lab <- c(\"Not looking\", \"looking\")\n\nfor(i in 1:m){\n  for(q in 1:q_emiss[2]){\n     plot(x = 1:1000, y = out_2st$emiss_prob_bar[[2]][,(i-1) * q_emiss[2] + q], \n          ylim = c(0,1.4), yaxt = 'n', type = \"l\", ylab = \"Transition probability\",\n          xlab = \"Iteration\", main = paste(\"Patient\", Look_lab[q], \"in state\", i), col = \"#8da0cb\") \n    axis(2, at = seq(0,1, .2), las = 2)\n    lines(x = 1:1000, y = out_2st_b$emiss_prob_bar[[2]][,(i-1) * q_emiss[2] + q], col = \"#e78ac3\")\n    legend(\"topright\", col = c(\"#8da0cb\", \"#e78ac3\"), lwd = 2, \n           legend = c(\"Starting value set 1\", \"Starting value set 2\"), bty = \"n\")\n  }\n}\n\n\n\n\n\n\n\nIt can be observed that the parameter estimates converge to the same parameter space, and that the chains mix well. Also, there is no evidence of label switching."
  }
]